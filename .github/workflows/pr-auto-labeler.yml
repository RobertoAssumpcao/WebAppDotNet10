name: Auto Label PR

on:
  pull_request:
    types: [opened, edited, synchronize]
    
permissions:
  pull-requests: write
  contents: read

jobs:
  labeler:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auto Label PR
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();
            const body = (pr.body || '').toLowerCase();
            
            try {
              // Obter files alterados
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              const labelsToAdd = new Set();
              const priorityLabels = new Set(['priority: high', 'priority: medium', 'priority: low']);
              const allAutoLabels = new Set([
                'bug', 'feature', 'documentation', 'enhancement',
                'priority: high', 'priority: medium', 'priority: low'
              ]);
              
              // An√°lise do t√≠tulo e descri√ß√£o
              if (title.includes('bug') || title.includes('fix') || body.includes('bug')) {
                labelsToAdd.add('bug');
              }
              
              if (title.includes('feature') || title.includes('feat') || body.includes('feature')) {
                labelsToAdd.add('feature');
              }
              
              if (title.includes('doc') || body.includes('doc')) {
                labelsToAdd.add('documentation');
              }
              
              if (title.includes('refactor') || body.includes('refactor')) {
                labelsToAdd.add('enhancement');
              }
              
              // An√°lise dos arquivos alterados
              const changedFiles = files.map(f => f.filename.toLowerCase());
              
              const hasDocChanges = changedFiles.some(f => 
                f.includes('readme') || f.includes('doc/') || f.includes('docs/')
              );
              
              const hasTestChanges = changedFiles.some(f => 
                f.includes('test') || f.includes('tests/')
              );
              
              const hasCriticalChanges = changedFiles.some(f =>
                f.includes('program.cs') || f.includes('dockerfile') || f.includes('.csproj') || f.includes('appsettings')
              );
              
              if (hasDocChanges) {
                labelsToAdd.add('documentation');
              }
              
              // Detectar prioridade (exclusiva - apenas uma)
              let priority = 'priority: medium'; // padr√£o
              
              if (title.includes('hotfix') || title.includes('[urgent]') || title.includes('urgent') || 
                  title.includes('critical') || body.includes('urgent') || body.includes('critical') ||
                  hasCriticalChanges) {
                priority = 'priority: high';
              } else if (title.includes('low priority') || body.includes('low priority')) {
                priority = 'priority: low';
              }
              
              labelsToAdd.add(priority);
              
              // Remover labels antigas de prioridade se existentes (ao editar)
              const currentLabels = pr.labels.map(l => l.name);
              const labelsToRemove = currentLabels.filter(label => 
                allAutoLabels.has(label) && !labelsToAdd.has(label)
              );
              
              // Remover labels antigas
              for (const label of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    name: label
                  });
                  console.log(`üóëÔ∏è Label removida: ${label}`);
                } catch (error) {
                  console.warn(`‚ö†Ô∏è N√£o foi poss√≠vel remover label "${label}":`, error.message);
                }
              }
              
              // Adicionar novas labels
              const labelsToAddFiltered = Array.from(labelsToAdd).filter(
                label => !currentLabels.includes(label)
              );
              
              if (labelsToAddFiltered.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: labelsToAddFiltered
                });
                console.log(`‚úÖ Labels adicionadas: ${labelsToAddFiltered.join(', ')}`);
              } else {
                console.log('‚ÑπÔ∏è Labels j√° est√£o atualizadas');
              }
              
              console.log(`üìù Resumo: ${Array.from(labelsToAdd).join(', ')}`);
              
            } catch (error) {
              console.error('‚ùå Erro ao processar labels:', error.message);
              throw error;
            }
